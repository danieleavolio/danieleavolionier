import{s as f,v as p,w as m,f as d,a as _,g,B as c,c as v,j as h,i as r,u as L,d as u}from"./scheduler.95a0eae5.js";import{S as z,i as M,b as x,d as T,m as $,a as b,t as I,e as C}from"./index.92efbcc7.js";import{g as S,a as y}from"./spread.8a54911c.js";import{M as D}from"./mdsvex.254dc05f.js";function U(l){let t,o="DATI",n,i,e='<li><p><strong>Università</strong>: Università della Calabria</p> <ul><li><strong>Laurea</strong>: Laurea Magistrale in Informatica e Intelligenza Artificiale</li> <li><strong>Voto</strong>: 110/110</li> <li><strong>Data</strong>: Settembre 2022 – Aprile 2025</li></ul></li> <li><p><strong>Tesi</strong>: <em>“L’uso di LLM in scenari di data migration and integration”</em></p> <ul><li><p><strong>Descrizione</strong>: Tesi incentrata sul miglioramento di un tool per la migrazione da XSLT (TIBCO) a DataWeave (MuleSoft), integrando Large Language Models (LLM) per automatizzare task come il refactoring del codice e l’assistenza agli sviluppatori tramite chatbot. Ho lavorato su UI/UX, automazione e applicazione pratica di AI generativa, ottenendo una significativa riduzione dei tempi di migrazione e un supporto avanzato agli utenti.</p></li> <li><p><strong>Tecnologie utilizzate</strong>:</p> <ul><li>Python</li> <li>Java</li> <li>DataWeave (MuleSoft)</li> <li>Spectrum (Informatica)</li></ul></li> <li><p><strong>Repository</strong>: Non disponibile pubblicamente.</p></li> <li><p><strong>Link (Italiano)</strong>: <a href="https://danieleavolio.it/MasterThesis.pdf" rel="nofollow">PDF</a></p></li></ul></li>';return{c(){t=d("h3"),t.textContent=o,n=_(),i=d("ul"),i.innerHTML=e,this.h()},l(a){t=g(a,"H3",{id:!0,"data-svelte-h":!0}),c(t)!=="svelte-1saiuh0"&&(t.textContent=o),n=v(a),i=g(a,"UL",{"data-svelte-h":!0}),c(i)!=="svelte-wdv6n7"&&(i.innerHTML=e),this.h()},h(){h(t,"id","dati")},m(a,s){r(a,t,s),r(a,n,s),r(a,i,s)},p:L,d(a){a&&(u(t),u(n),u(i))}}}function w(l){let t,o;const n=[l[0]];let i={$$slots:{default:[U]},$$scope:{ctx:l}};for(let e=0;e<n.length;e+=1)i=p(i,n[e]);return t=new D({props:i}),{c(){x(t.$$.fragment)},l(e){T(t.$$.fragment,e)},m(e,a){$(t,e,a),o=!0},p(e,[a]){const s=a&1?S(n,[y(e[0])]):{};a&2&&(s.$$scope={dirty:a,ctx:e}),t.$set(s)},i(e){o||(b(t.$$.fragment,e),o=!0)},o(e){I(t.$$.fragment,e),o=!1},d(e){C(t,e)}}}function A(l,t,o){return l.$$set=n=>{o(0,t=p(p({},t),m(n)))},t=m(t),[t]}class P extends z{constructor(t){super(),M(this,t,A,w,f,{})}}export{P as default};
